---
description: Хуки позволяют вам использовать различные функции React из ваших компонентов. Вы можете использовать встроенные хуки или комбинировать их для создания своих собственных
---

# Обзор хуков

<big>**Хуки** позволяют вам использовать различные функции React из ваших компонентов. Вы можете использовать встроенные хуки или комбинировать их для создания своих собственных. На этой странице перечислены все встроенные хуки в React.</big>

## Хуки состояния {#state-hooks}

_Состояние_ позволяет компоненту ["запоминать" информацию, например, вводимую пользователем](../../learn/state-a-components-memory.md). Например, компонент формы может использовать состояние для хранения значения ввода, а компонент галереи изображений - для хранения индекса выбранного изображения.

Чтобы добавить состояние в компонент, используйте один из этих хуков:

-   [`useState`](useState.md) объявляет переменную состояния, которую вы можете обновлять напрямую.
-   [`useReducer`](useReducer.md) объявляет переменную состояния с логикой обновления внутри функции [reducer](../../learn/extracting-state-logic-into-a-reducer.md).

```js
function ImageGallery() {
    const [index, setIndex] = useState(0);
    // ...
}
```

## Контекстные хуки {#context-hooks}

_Контекст_ позволяет компоненту [получать информацию от удаленных родителей, не передавая ее в виде пропсов](../../learn/passing-props-to-a-component.md). Например, компонент верхнего уровня вашего приложения может передавать текущую тему пользовательского интерфейса всем компонентам ниже, независимо от глубины.

-   [`useContext`](useContext.md) читает и подписывается на контекст.

```js
function Button() {
    const theme = useContext(ThemeContext);
    // ...
}
```

## Реф хуки {#ref-hooks}

_Рефы_ позволяют компоненту [хранить некоторую информацию, которая не используется для рендеринга,](../../learn/referencing-values-with-refs.md) например, узел DOM или идентификатор таймаута. В отличие от состояния, обновление рефа не приводит к повторному рендерингу компонента. Рефы - это "аварийный люк" из парадигмы React. Они полезны, когда вам нужно работать с системами, не относящимися к React, например, со встроенными API браузера.

-   [`useRef`](useRef.md) объявляет реф. Вы можете хранить в нем любое значение, но чаще всего он используется для хранения узла DOM.
-   [`useImperativeHandle`](useImperativeHandle.md) позволяет вам настроить реф, открываемый вашим компонентом. Это редко используется.

```js
function Form() {
    const inputRef = useRef(null);
    // ...
}
```

## Хуки эффектов {#effect-hooks}

_Эффекты_ позволяют компоненту [подключаться к внешним системам и синхронизироваться с ними](../../learn/synchronizing-with-effects.md) Это включает работу с сетью, DOM браузера, анимацией, виджетами, написанными с использованием другой библиотеки UI, и другим не-React кодом.

-   [`useEffect`](useEffect.md) подключает компонент к внешней системе.

```js
function ChatRoom({ roomId }) {
    useEffect(() => {
        const connection = createConnection(roomId);
        connection.connect();
        return () => connection.disconnect();
    }, [roomId]);
    // ...
}
```

Эффекты - это "аварийный люк" из парадигмы React. Не используйте эффекты для оркестровки потока данных в вашем приложении. Если вы не взаимодействуете с внешней системой, [возможно, вам не нужен эффект](../../learn/you-might-not-need-an-effect.md).

Есть две редко используемые вариации `useEffect` с различиями во времени:

-   [`useLayoutEffect`](useLayoutEffect.md) срабатывает до того, как браузер перерисовывает экран. Вы можете измерить компоновку здесь.
-   [`useInsertionEffect`](useInsertionEffect.md) срабатывает до того, как React внесет изменения в DOM. Здесь библиотеки могут вставлять динамические CSS.

## Хуки производительности {#performance-hooks}

Общий способ оптимизации производительности повторного рендеринга - пропустить ненужную работу. Например, вы можете указать React повторно использовать кэшированные вычисления или пропустить повторный рендеринг, если данные не изменились с момента предыдущего рендеринга.

Чтобы пропустить вычисления и ненужный повторный рендеринг, используйте один из этих хуков:

-   [`useMemo`](useMemo.md) позволяет кэшировать результат дорогостоящего вычисления.
-   [`useCallback`](useCallback.md) позволяет кэшировать определение функции перед передачей ее оптимизированному компоненту.

```js
function TodoList({ todos, tab, theme }) {
    const visibleTodos = useMemo(
        () => filterTodos(todos, tab),
        [todos, tab]
    );
    // ...
}
```

Иногда нельзя пропустить повторный рендеринг, потому что экран действительно должен обновляться. В этом случае можно повысить производительность, отделив блокирующие обновления, которые должны быть синхронными (например, ввод данных в поле ввода), от неблокирующих обновлений, которые не должны блокировать пользовательский интерфейс (например, обновление графика).

Чтобы установить приоритет рендеринга, используйте один из этих хуков:

-   [`useTransition`](useTransition.md) позволяет пометить переход состояния как неблокирующий и разрешить другим обновлениям прерывать его.
-   [`useDeferredValue`](useDeferredValue.md) позволяет отложить обновление некритичной части пользовательского интерфейса и позволить другим частям обновляться первыми.

## Хуки ресурсов {#resource-hooks}

Компонент может получить доступ к ресурсам, не имея их в качестве части своего состояния. Например, компонент может прочитать сообщение из Promise или прочитать информацию о стиле из контекста.

Чтобы прочитать значение из ресурса, используйте этот хук:

-   [`use`](use.md) позволяет прочитать значение ресурса, например [Promise](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise) или [context](../../learn/passing-data-deeply-with-context.md).

```js
function MessageComponent({ messagePromise }) {
    const message = use(messagePromise);
    const theme = use(ThemeContext);
    // ...
}
```

## Другие хуки {#other-hooks}

Эти хуки в основном полезны авторам библиотек и не часто используются в коде приложения.

-   [`useDebugValue`](useDebugValue.md) позволяет вам настроить метку, которую React DevTools отображает для вашего пользовательского хука.
-   [`useId`](useId.md) позволяет компоненту связать с собой уникальный ID. Обычно используется в API доступности.
-   [`useSyncExternalStore`](useSyncExternalStore.md) позволяет компоненту подписаться на внешний магазин.

## Ваши собственные хуки {#your-own-hooks}

Вы также можете [определить собственные пользовательские хуки](../../learn/reusing-logic-with-custom-hooks.md) как функции JavaScript.

<small>:material-information-outline: Источник &mdash; [https://react.dev/reference/react/hooks](https://react.dev/reference/react/hooks)</small>
