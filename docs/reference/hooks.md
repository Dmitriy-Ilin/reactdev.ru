# Обзор хуков

_Хуки_ позволяют вам использовать различные функции React из ваших компонентов. Вы можете использовать встроенные хуки или комбинировать их для создания своих собственных. На этой странице перечислены все встроенные хуки в React.

## Хуки состояния

_Состояние_ позволяет компоненту ["запоминать" информацию, например, вводимую пользователем](../learn/state-a-components-memory.md). Например, компонент формы может использовать состояние для хранения значения ввода, а компонент галереи изображений - для хранения индекса выбранного изображения.

Чтобы добавить состояние в компонент, используйте один из этих хуков:

-   [`useState`](useState.md) объявляет переменную состояния, которую вы можете обновлять напрямую.
-   [`useReducer`](useReducer.md) объявляет переменную состояния с логикой обновления внутри функции [reducer.](../learn/extracting-state-logic-into-a-reducer.md).

<!-- конец списка -->

<!-- 0001.part.md -->

```js
function ImageGallery() {
    const [index, setIndex] = useState(0);
    // ...
}
```

<!-- 0002.part.md -->

## Контекстные хуки

_Контекст_ позволяет компоненту [получать информацию от удаленных родителей, не передавая ее в виде пропсов](../learn/passing-props-to-a-component.md). Например, компонент верхнего уровня вашего приложения может передавать текущую тему пользовательского интерфейса всем компонентам ниже, независимо от глубины.

-   [`useContext`](useContext.md) читает и подписывается на контекст.

<!-- конец списка -->

<!-- 0003.part.md -->

```js
function Button() {
    const theme = useContext(ThemeContext);
    // ...
}
```

<!-- 0004.part.md -->

## Ссылочные хуки

_Рефы_ позволяют компоненту [хранить некоторую информацию, которая не используется для рендеринга,](../learn/referencing-values-with-refs.md) например, узел DOM или идентификатор таймаута. В отличие от состояния, обновление ссылки не приводит к повторному рендерингу компонента. Ссылки - это "аварийный люк" из парадигмы React. Они полезны, когда вам нужно работать с системами, не относящимися к React, например, со встроенными API браузера.

-   [`useRef`](useRef.md) объявляет ссылку. Вы можете хранить в нем любое значение, но чаще всего он используется для хранения узла DOM.
-   [`useImperativeHandle`](useImperativeHandle.md) позволяет вам настроить ссылку, открываемую вашим компонентом. Это редко используется.

<!-- конец списка -->

<!-- 0005.part.md -->

```js
function Form() {
    const inputRef = useRef(null);
    // ...
}
```

<!-- 0006.part.md -->

## Хуки эффектов

_Эффекты_ позволяют компоненту [подключаться к внешним системам и синхронизироваться с ними](../learn/synchronizing-with-effects.md) Это включает работу с сетью, DOM браузера, анимацией, виджетами, написанными с использованием другой библиотеки UI, и другим не-React кодом.

-   [`useEffect`](useEffect.md) подключает компонент к внешней системе.

<!-- конец списка -->

<!-- 0007.part.md -->

```js
function ChatRoom({ roomId }) {
    useEffect(() => {
        const connection = createConnection(roomId);
        connection.connect();
        return () => connection.disconnect();
    }, [roomId]);
    // ...
}
```

<!-- 0008.part.md -->

Эффекты - это "аварийный люк" из парадигмы React. Не используйте эффекты для оркестровки потока данных в вашем приложении. Если вы не взаимодействуете с внешней системой, [возможно, вам не нужен эффект](../learn/you-might-not-need-an-effect.md).

Есть две редко используемые вариации `useEffect` с различиями во времени:

-   [`useLayoutEffect`](useLayoutEffect.md) срабатывает до того, как браузер перерисовывает экран. Вы можете измерить компоновку здесь.
-   [`useInsertionEffect`](useInsertionEffect.md) срабатывает до того, как React внесет изменения в DOM. Здесь библиотеки могут вставлять динамические CSS.

## Производительность хуков

Общий способ оптимизации производительности повторного рендеринга - пропустить ненужную работу. Например, вы можете указать React повторно использовать кэшированные вычисления или пропустить повторный рендеринг, если данные не изменились с момента предыдущего рендеринга.

Чтобы пропустить вычисления и ненужный повторный рендеринг, используйте один из этих хуков:

-   [`useMemo`](useMemo.md) позволяет кэшировать результат дорогостоящего вычисления.
-   [`useCallback`](useCallback.md) позволяет кэшировать определение функции перед передачей ее оптимизированному компоненту.

<!-- конец списка -->

<!-- 0009.part.md -->

```js
function TodoList({ todos, tab, theme }) {
    const visibleTodos = useMemo(
        () => filterTodos(todos, tab),
        [todos, tab]
    );
    // ...
}
```

<!-- 0010.part.md -->

Иногда нельзя пропустить повторный рендеринг, потому что экран действительно должен обновляться. В этом случае можно повысить производительность, отделив блокирующие обновления, которые должны быть синхронными (например, ввод данных в поле ввода), от неблокирующих обновлений, которые не должны блокировать пользовательский интерфейс (например, обновление графика).

Чтобы установить приоритет рендеринга, используйте один из этих хуков:

-   [`useTransition`](useTransition.md) позволяет пометить переход состояния как неблокирующий и разрешить другим обновлениям прерывать его.
-   [`useDeferredValue`](useDeferredValue.md) позволяет отложить обновление некритичной части пользовательского интерфейса и позволить другим частям обновляться первыми.

## Другие хуки

Эти хуки в основном полезны авторам библиотек и не часто используются в коде приложения.

-   [`useDebugValue`](useDebugValue.md) позволяет вам настроить метку, которую React DevTools отображает для вашего пользовательского хука.
-   [`useId`](useId.md) позволяет компоненту связать с собой уникальный ID. Обычно используется в API доступности.
-   [`useSyncExternalStore`](useSyncExternalStore.md) позволяет компоненту подписаться на внешний магазин.

## Ваши собственные хуки

Вы также можете [определить собственные пользовательские хуки](../learn/reusing-logic-with-custom-hooks.md) как функции JavaScript.

## Ссылки

-   [https://react.dev/reference/react](https://react.dev/reference/react)
